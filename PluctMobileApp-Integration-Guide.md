# PluctMobileApp Integration Guide
## Complete API Reference and Integration Documentation

### Overview

The Pluct Business Engine is a production-ready Cloudflare Worker that serves as the gateway between your mobile application and the TTTranscribe transcription service. It implements bulletproof credit enforcement, JWT-based authentication, and provides secure proxy services for TikTok video transcription and AI analysis.

### Base Configuration

**Production Base URL:** `https://pluct-business-engine.romeo-lya2.workers.dev`

**Environment:** Production-ready with comprehensive error handling, rate limiting, and audit logging.

---

## Authentication System

### JWT Token Structure

The system uses two types of JWT tokens:

#### 1. User Authentication Token (Long-lived)
Used for authenticating users and accessing user-specific endpoints.

**Payload Structure:**
```json
{
  "sub": "user_id",
  "scope": "ttt:transcribe", 
  "iat": 1640995200,
  "exp": 1640996100
}
```

**Generation Requirements:**
- Algorithm: HS256
- Secret: `ENGINE_JWT_SECRET` (from environment)
- Expiration: 15 minutes (900 seconds)
- Required Scope: `ttt:transcribe`

#### 2. Service Token (Short-lived)
Generated by the engine for TTTranscribe service access.

**Payload Structure:**
```json
{
  "sub": "user_id",
  "scope": "ttt:transcribe",
  "iat": 1640995200,
  "exp": 1640996100
}
```

**Characteristics:**
- 15-minute expiration
- Automatically generated by `/v1/vend-token` endpoint
- Costs 1 credit per generation
- Required for all `/ttt/*` endpoints

---

## API Endpoints Reference

### Health and Monitoring

#### GET `/health`
**Purpose:** System health check and configuration status
**Authentication:** None required
**Response:**
```json
{
  "status": "ok",
  "uptimeSeconds": 3600,
  "version": "1.0.0",
  "routes": {
    "health": [
      {"method": "GET", "path": "/", "description": "Root endpoint"},
      {"method": "GET", "path": "/health", "description": "Health check"}
    ],
    "authentication": [
      {"method": "POST", "path": "/v1/vend-token", "description": "Vend access token"},
      {"method": "GET", "path": "/v1/credits/balance", "description": "Get credit balance"}
    ],
    "transcription": [
      {"method": "POST", "path": "/ttt/transcribe", "description": "Start transcription"},
      {"method": "GET", "path": "/ttt/status/:id", "description": "Check status"}
    ],
    "metadata": [
      {"method": "GET", "path": "/meta", "description": "Get TikTok metadata"},
      {"method": "POST", "path": "/meta/resolve", "description": "Resolve metadata"}
    ]
  }
}
```

#### GET `/health/services`
**Purpose:** Detailed service health monitoring
**Authentication:** None required
**Response:**
```json
{
  "status": "ok",
  "services": {
    "kv": "healthy",
    "ttt": "healthy",
    "auth": "healthy"
  },
  "timestamp": "2024-10-15T03:30:00.000Z"
}
```

---

### Credit Management

#### GET `/v1/credits/balance`
**Purpose:** Get user's current credit balance
**Authentication:** User JWT Bearer token required
**Headers:**
```
Authorization: Bearer <user_jwt_token>
```
**Response:**
```json
{
  "ok": true,
  "userId": "user123",
  "balance": 15,
  "updatedAt": "2024-10-15T03:30:00.000Z"
}
```

#### POST `/v1/vend-token`
**Purpose:** Generate short-lived service token (costs 1 credit)
**Authentication:** User JWT Bearer token required
**Headers:**
```
Authorization: Bearer <user_jwt_token>
Content-Type: application/json
```
**Request Body:**
```json
{
  "userId": "user123",
  "clientRequestId": "unique_request_id_optional"
}
```
**Response (Success):**
```json
{
  "ok": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 900,
  "balanceAfter": 14,
  "requestId": "req_1640995200000"
}
```
**Response (Insufficient Credits - 402):**
```json
{
  "ok": false,
  "code": "insufficient_credits",
  "message": "Insufficient credits",
  "details": {
    "balance": 0,
    "required": 1
  },
  "guidance": "Add credits to your account to continue"
}
```

---

### Transcription Services

#### POST `/ttt/transcribe`
**Purpose:** Start transcription job for TikTok video
**Authentication:** Service JWT Bearer token required
**Timeout:** 10 minutes (600,000ms)
**Headers:**
```
Authorization: Bearer <service_jwt_token>
Content-Type: application/json
```
**Request Body:**
```json
{
  "url": "https://www.tiktok.com/@username/video/1234567890",
  "clientRequestId": "unique_request_id_optional"
}
```
**Response (Success - 202):**
```json
{
  "ok": true,
  "jobId": "ttt_abc123",
  "status": "queued",
  "submittedAt": "2024-10-15T03:30:00.000Z",
  "request_id": "ttt_abc123"
}
```

#### GET `/ttt/status/:id`
**Purpose:** Check transcription job status
**Authentication:** Service JWT Bearer token required
**Timeout:** 30 seconds (default)
**Headers:**
```
Authorization: Bearer <service_jwt_token>
```
**Response (In Progress):**
```json
{
  "ok": true,
  "jobId": "ttt_abc123",
  "status": "processing",
  "progress": 45,
  "estimatedCompletion": "2024-10-15T03:35:00.000Z"
}
```
**Response (Completed):**
```json
{
  "ok": true,
  "jobId": "ttt_abc123",
  "status": "completed",
  "progress": 100,
  "result": {
    "transcription": "Full transcription text here...",
    "confidence": 0.95,
    "language": "en",
    "duration": 30.5
  }
}
```

---

### Metadata Services

#### GET `/meta?url=<tiktok_url>`
**Purpose:** Get TikTok video metadata with caching
**Authentication:** None required
**Query Parameters:**
- `url`: TikTok video URL (required)

**Response:**
```json
{
  "title": "TikTok Video Title",
  "author": "username",
  "description": "Video description",
  "duration": 30,
  "handle": "@username",
  "url": "https://www.tiktok.com/@username/video/1234567890"
}
```

#### POST `/meta/resolve`
**Purpose:** Resolve TikTok metadata and prepare for transcription
**Authentication:** None required
**Request Body:**
```json
{
  "url": "https://www.tiktok.com/@username/video/1234567890"
}
```
**Response:**
```json
{
  "meta": {
    "title": "TikTok Video Title",
    "author": "username", 
    "description": "Video description",
    "duration": 30,
    "handle": "@username",
    "url": "https://www.tiktok.com/@username/video/1234567890"
  },
  "job": {
    "id": "job_1640995200000_abc123",
    "status": "queued",
    "submittedAt": "2024-10-15T03:30:00.000Z"
  }
}
```

---

## Error Handling

### Standard Error Response Format

All error responses follow this consistent structure:

```json
{
  "ok": false,
  "code": "error_code",
  "message": "Human readable error message",
  "details": {
    "additional": "context information"
  },
  "build": {
    "ref": "build_reference",
    "deployedAt": "2024-10-15T03:00:00.000Z"
  },
  "guidance": "Helpful guidance for resolution"
}
```

### Common Error Codes

| Code | HTTP Status | Description | Resolution |
|------|-------------|-------------|------------|
| `unauthorized` | 401 | Missing or invalid authentication | Provide valid JWT token |
| `forbidden` | 403 | Insufficient scope or permissions | Use token with correct scope |
| `insufficient_credits` | 402 | Not enough credits for operation | Add credits to account |
| `rate_limit_exceeded` | 429 | Too many requests | Wait before retrying |
| `invalid_url` | 422 | Invalid TikTok URL format | Provide valid TikTok URL |
| `job_not_found` | 404 | Transcription job not found | Check job ID |
| `upstream_error` | 502/504 | TTTranscribe service error | Retry or contact support |
| `token_vending_failed` | 500 | Token generation failed | Retry or contact support |

---

## Rate Limiting

### Limits
- **Token Vending:** 10 requests per hour per user
- **General API:** 100 requests per minute per user
- **Metadata Resolution:** No specific limits (cached responses)

### Rate Limit Response (429)
```json
{
  "ok": false,
  "code": "rate_limit_exceeded",
  "message": "Rate limit exceeded",
  "details": {
    "limit": 10,
    "resetTime": "2024-10-15T04:30:00.000Z"
  },
  "guidance": "Please wait before making another request"
}
```

---

## Complete User Journey Implementation

### 1. User Registration and Credit Setup

```kotlin
// Step 1: Create user JWT token
fun createUserJWT(userId: String): String {
    val now = System.currentTimeMillis() / 1000
    val payload = mapOf(
        "sub" to userId,
        "scope" to "ttt:transcribe",
        "iat" to now,
        "exp" to (now + 900) // 15 minutes
    )
    
    val secret = "prod-jwt-secret-Z8qKsL2wDn9rFy6aVbP3tGxE0cH4mN5jR7sT1uC9e"
    return JWT.create()
        .withPayload(payload)
        .withExpiresAt(Date(now + 900 * 1000))
        .sign(Algorithm.HMAC256(secret))
}

// Step 2: Check user balance
fun checkUserBalance(userId: String): Int {
    val token = createUserJWT(userId)
    val response = httpClient.get("/v1/credits/balance") {
        header("Authorization", "Bearer $token")
    }
    return response.jsonObject.getInt("balance")
}
```

### 2. TikTok Video Processing Flow

```kotlin
// Step 1: Get video metadata
fun getVideoMetadata(tiktokUrl: String): VideoMetadata {
    val response = httpClient.get("/meta") {
        parameter("url", tiktokUrl)
    }
    return VideoMetadata.fromJson(response.jsonObject)
}

// Step 2: Vend service token (costs 1 credit)
fun vendServiceToken(userId: String): String {
    val userToken = createUserJWT(userId)
    val response = httpClient.post("/v1/vend-token") {
        header("Authorization", "Bearer $userToken")
        header("Content-Type", "application/json")
        setBody(JSON.stringify(mapOf("userId" to userId)))
    }
    
    if (!response.jsonObject.getBoolean("ok")) {
        throw InsufficientCreditsException(response.jsonObject.getString("message"))
    }
    
    return response.jsonObject.getString("token")
}

// Step 3: Start transcription (10-minute timeout)
fun startTranscription(tiktokUrl: String, userId: String): String {
    val serviceToken = vendServiceToken(userId)
    val response = httpClient.post("/ttt/transcribe") {
        header("Authorization", "Bearer $serviceToken")
        header("Content-Type", "application/json")
        setBody(JSON.stringify(mapOf("url" to tiktokUrl)))
        // Note: 10-minute timeout is handled automatically by the engine
    }
    
    return response.jsonObject.getString("jobId")
}

// Step 4: Monitor transcription status (30-second timeout)
fun checkTranscriptionStatus(jobId: String, userId: String): TranscriptionStatus {
    val serviceToken = vendServiceToken(userId)
    val response = httpClient.get("/ttt/status/$jobId") {
        header("Authorization", "Bearer $serviceToken")
        // Note: 30-second timeout is handled automatically by the engine
    }
    
    return TranscriptionStatus.fromJson(response.jsonObject)
}
```

### 3. Error Handling Implementation

```kotlin
class PluctApiClient {
    fun handleApiResponse(response: HttpResponse): ApiResult {
        return when (response.status.value) {
            200, 202 -> ApiResult.Success(response.jsonObject)
            401 -> ApiResult.Error.Unauthorized(response.jsonObject.getString("message"))
            402 -> ApiResult.Error.InsufficientCredits(response.jsonObject.getString("message"))
            403 -> ApiResult.Error.Forbidden(response.jsonObject.getString("message"))
            404 -> ApiResult.Error.NotFound(response.jsonObject.getString("message"))
            422 -> ApiResult.Error.InvalidInput(response.jsonObject.getString("message"))
            429 -> ApiResult.Error.RateLimited(response.jsonObject.getString("message"))
            500, 502, 504 -> ApiResult.Error.ServerError(response.jsonObject.getString("message"))
            else -> ApiResult.Error.Unknown(response.jsonObject.getString("message"))
        }
    }
}
```

---

## Security Considerations

### Required Headers for Mobile App

```kotlin
// For user authentication
"Authorization": "Bearer <JWT_TOKEN>"

// For admin operations (if needed)
"X-API-Key": "engine-shared-secret-Yf9pR3kLx2tN6vQ4mC1aS8bE5wG7zH0jU9rK3dP6qT1nV8xL4fZ2yM7cJ5aB9eR"

// For request deduplication
"X-Client-Request-Id": "<UNIQUE_REQUEST_ID>"
"X-User-ID": "<USER_ID>"
```

### JWT Token Security
- Tokens expire in 15 minutes
- Use HTTPS for all communications
- Store tokens securely in mobile app
- Implement token refresh logic
- Never log or expose JWT tokens

---

## Credit System Integration

### Credit Consumption
- **Token Vending:** 1 credit per service token
- **Transcription:** Service tokens are required but don't consume additional credits
- **Metadata Resolution:** Free (cached)

### Credit Purchase Flow
1. User initiates purchase in mobile app
2. Process payment through your payment system
3. Call admin endpoint to add credits:
   ```kotlin
   fun addCredits(userId: String, amount: Int) {
       val response = httpClient.post("/v1/credits/add") {
           header("X-API-Key", "admin-api-key")
           header("Content-Type", "application/json")
           setBody(JSON.stringify(mapOf(
               "userId" to userId,
               "amount" to amount,
               "reason" to "purchase"
           )))
       }
   }
   ```

---

## Testing and Validation

### Health Check
```kotlin
fun checkSystemHealth(): Boolean {
    val response = httpClient.get("/health")
    return response.jsonObject.getString("status") == "ok"
}
```

### End-to-End Test Flow
1. Health check
2. Create user token
3. Check balance
4. Vend service token
5. Get video metadata
6. Start transcription (with 10-minute timeout)
7. Monitor status (with 30-second timeout)
8. Retrieve results

---

## Performance Considerations

### Caching
- Metadata responses are cached for 1-6 hours
- Use `clientRequestId` for idempotency
- Implement local caching for frequently accessed data

### Timeouts
- **Transcription Jobs:** 10 minutes maximum processing time
- **Status Checks:** 30 seconds timeout
- **Service Token Expiration:** 15 minutes
- **Request Timeout:** Handled automatically by endpoint type

### Retry Logic
- Implement exponential backoff for failed requests
- Retry on 5xx errors
- Don't retry on 4xx errors (except 429)

---

## Monitoring and Logging

### Audit Trail
All operations are logged with:
- User ID
- Request ID
- Timestamp
- IP address
- User agent
- Success/failure status

### Error Tracking
- Structured error responses with error codes
- Build information for debugging
- Guidance messages for resolution

---

This comprehensive guide provides everything needed for the PluctMobileApp to effectively communicate with the Pluct Business Engine. The system is production-ready with robust error handling, security measures, and comprehensive audit logging to support your monetization strategy.
